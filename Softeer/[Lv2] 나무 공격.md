
# 문제

환경 파괴범 때문에 화가 난 숲의 요정은 나무 공격을 진행하려 합니다. 나무 공격 진행시 투사체 5개가 생성되어 지정된 방향으로 전진합니다. 각 투사체와 최초로 접촉한 환경 파괴범은 사라지게 되며 이때 투사체 역시 동시에 사라지게 됩니다. 만약 투사체가 환경 파괴범과 마주치지 않는다면 조용히 사라지게 됩니다.
이는 n×m 크기의 격자에서 진행됩니다. 초기에 격자의 각 칸에는 숫자 0 또는 1이 적혀있으며 0은 비어있음을, 1은 환경 파괴범이 해당 위치에 서있음을 뜻합니다.
숲의 요정은 항상 격자의 왼쪽 방향에서 나무 공격을 진행하며, 총 2회 진행합니다. 공격은 특정 행 L부터 행 R까지의 구간에 한하여 투사체를 만들어 진행하게 되며, 모든 투사체는 행 변화 없이 정확히 오른쪽 방향으로만 진행하게 됩니다. 투사체는 처음으로 만나는 환경 파괴범과 함께 사라지게 되며, 끝까지 만나지 않는 투사체는 조용히 사라지게 됩니다. L과 R의 차이는 항상 4이기 때문에 투사체는 항상 5개가 만들어짐에 유의합니다. 다음은 1~5 행에 걸쳐 공격을 진행한 경우입니다.
초기 격자의 정보와 2번의 공격에 대한 정보가 주어졌을 때, 공격을 순서대로 진행한 이후 격자에 남아있는 서로 다른 환경 파괴범의 수를 구하는 프로그램을 작성해보세요.

# 풀이

2차원 배열로 주어지지만 간단하게 row 기준으로 생각해도 되는 문제이다.
각 row별 환경 파괴범의 수를 합하고 a, b가 주어졌을 때 a~b까지 row의 합-1을 해주면 되는 쉬운 문제이다.

# 코드
```
#include <iostream>
using namespace std;

int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);

    int n, m;
    cin >> n >> m;
    int rowSum[101] = {0};

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            int t;
            cin >> t;
            rowSum[i] += t;
        }
    }

    for (int q = 0; q < 2; q++) {
        int a, b;
        cin >> a >> b;
        for (int i = a - 1; i < b && i < n; i++) {
            rowSum[i]--;
        }
    }

    int total = 0;
    for (int i = 0; i < n; i++) {
        if (rowSum[i] > 0) {
            total += rowSum[i];
        }
    }

    cout << total;
    return 0;
}
```